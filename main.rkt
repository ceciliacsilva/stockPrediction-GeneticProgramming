#lang racket

(provide (all-defined-out))

(require "geneticOperation.rkt")
(require "expression.rkt")
(require "config.rkt")

(require "drawTree.rkt")

(define (gp-run listPrice gp)
  (let ( (np (gp-np gp))
         (nElite (gp-nElite gp))
         (endSimul (gp-endSimul gp))
         (nRepeat (gp-nRepeat gp)) )
    (let ( (popBegin (gp-begin-population gp listPrice)) )
      (let loop ( (pop0  popBegin)
                  (best '())
                  (repeatBest  0)
                  (repeat      1) )
        (let ( (popCrossover
                (for/fold ( (pop1 '()) )
                          ( (i (in-range (/ np 2))) )
                  (values (append pop1 (genetic-operations pop0 gp listPrice))) ))  )
          (let* ( (pop0Elite (population-elite pop0 nElite))
                  (pop1All (append popCrossover pop0Elite))
                  (pop1 (population-elite pop1All np))
                  (bestPop (first (population-elite pop1 1))) )
            ;;(map displayln pop1)
            ;;(displayln "\n\n")
            (if (or (= repeatBest nRepeat) (= repeat endSimul))
                best
                (loop pop1
                      bestPop
                      (if (equal? best bestPop) (add1 repeatBest) 0)
                      (add1 repeat) ))
            )
          )
        ))
    )
  )
(define (gp-begin-population gp listPrice)
  (let ( (np (gp-np gp))
         (operators (gp-operators gp))
         (depth (gp-depth gp)) )
    
    (append (for/list ( (i (in-range (/ np 2))) )
              (gen-expression-full operators gp listPrice))
            (for/list ( (i (in-range (/ np 2))) )
              (gen-expression-grow operators gp listPrice)) )
    )
  )

(define (genetic-operations pop gp listPrice)
  (let ( (operators (gp-operators gp))
         (tournament (tournament-create pop gp)) )
    (let ( (progn1 (tournament-selection tournament gp))
           (progn2 (tournament-selection tournament gp)) )
      (let-values ( ((f1 f2) (crossover progn1 progn2 gp)) )
        ;(displayln f1)
        ;(displayln f2)
        ;(displayln "")
        (let ( (progn1 (mutation f1 operators gp listPrice))
               (progn2 (mutation f2 operators gp listPrice)) )
          ;(displayln progn1)
          ;(displayln progn2)
          ;(displayln "")
          (list `(,progn1 . ,(fitness-eval progn1 listPrice gp))
                `(,progn2 . ,(fitness-eval progn2 listPrice gp))) )
        )
      ))
  )
               

(define (tournament-create pop gp)
  (let ( (np (gp-np gp))
         (nTournament (gp-nTournament gp)) )
    (population-elite 
     (for/list ( (i (in-range nTournament)) )
       (list-ref pop (random np)))
     nTournament)
    )
  )

(define (tournament-selection tournament gp)
  (let ( (k (gp-k gp)) )
    (let ( (na (random)) )
      (if (<= na k)
          (first tournament)
          (last  tournament))  ))  )

(define (population-elite pop n)
  (let ( (popSort (sort pop #:key cdr >)) )
    (take popSort n)) )

